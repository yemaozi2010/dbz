0.配置Git用户信息
git config --global user.naem "yemaozi2010"
git config --global user.email "hshunzhong1212@163.com"
git config --list   //查看config信息
1.初始化一个Git仓库
mkdir learngit
git init
2.添加文件到Git仓库
git add readme.txt
gtit commit -m "wrote a readme file"
git add file1.txt
git add file2.txt file3.txt
git commit -m "add 3 files"
3.查看仓库当前到状态
git status
4.查看与上次提交修改的内容有什么不同之处
git diff
5.显示从最近开始到最远到提交日志
git log
git log --pretty=oneline  //每条记录按一行来显示
6.在Git中，用HEAD表示当前版本，也就是最新的提交，上一个
版本就是HEAD^，上上个版本就是HEAD^^，往上100个版本就是
HEAD-100
git reset --hard 28828282  //回退到版本ID为28828282的版本
          //无需写全版本号，写前几位就可以了，git会自动匹配
git reset --hard HEAD^   //回退到上一个版本
7.Git提供了一个命令来记录你的每一次命令
git reflog
8.工作区和缓存区
Git和其他版本控制系统如SVN的一个不同之处就是有缓存区到概念。
工作区(Working Directory)就是电脑中看到的目录，比如
/home/bbwl/learngit文件夹就是一个工作区。
版本库(Repository)，工作区中有一个隐藏目录.git，这个可以看作
Git的版本库。
Git的版本库里存放了很多东西，其中最重要的就是被称为stageu（或者
叫index）的缓存区，还有Git为我们自动创建的第一个分支master，以及
指向master的一个指针叫HEAD。
我们把文件往Git版本库里添加的时候，是分两步执行的：
第一步用git add把文件添加进去，实际上就是把文件修改添加到缓冲区；
第二步用git commit提交更改，实际上就是把缓存区的所有内容提交到
当前分支。
9.管理修改
为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是
修改，而非文件。
git diff HEAD -- readme.txt  
//查看工作区和版本库里面最新本版的区别。
10.撤销修改
git checkout -- filename可以丢弃工作区的修改
命令git checkout -- readme.txt的意思是，把readme.txt文件在工作
区的修改全部撤销，这里有两种情况：
一种是readme.txt自己修改后还没有被放到缓存区，现在，撤销修改就是
回到和版本库一模一样的状态；
一种是readme.txt已经添加到缓存库，又做了修改，现在，撤销修改就是
回到添加到缓存区后的状态。
总之，就是让这个文件回到最近一次git commit或git add的状态。
git checkout -- filename 命令中到--很重要，没有--，就变成了“切换
到另一个分支"。
git reset HEAD filename 可以把缓存区到修改撤销(unstage)，重新
放回工作区。
git reset HEAD readme.txt 
git reset 命令既可以回退版本，也可以把缓存区到修改回退到工作区。
HEAD表示最新的版本。
撤销修改有如下3种场景：
场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区到修改
时，用命令 git checkout -- filename。
场景2：当你不但改乱了工作区某个文件的内容，还添加到了缓存区时，
想丢弃修改，分两步，第一步用命令 git reset HEAD filename，将修改
从缓存区中移除，就回到了场景1，第二步按场景1操作。
场景3：已经提交了不合格的修改到版本库时，想要撤销本次提交，此时
需要版本回退，不过前提是没有推送到远程库。
10.删除文件
rm file1.txt
通过git status Git告诉你工作区和版本库不一致了，同时告诉你哪些
文件被删除了。此时有两种选择，一是确实要从版本库中删除该文件
git rm file1.txt
git commit -m "remove file1.txt"
另一种情况是删错了，因为版本库里还有，所以可以很轻松地把误删的
文件恢复到最新的版本，
git checkout -- file1.txt
git checkout其实就是用版本库里的版本替换工作区到版本，无论工作
区是修改还是删除，都可以"一键还原"。
命令git rm 用于删除一个文件。如果一个文件已经被提交到版本库，
那么你永远不用担心误删，但要小心，你只能恢复文件到最新版本，
你会丢失最近一次提交后你修改的内容。
11.远程仓库
Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。
怎么分布呢？最早，肯定只有一台机器有一个原始版本，此后，别的机器
可以“克隆”这个原始版本，而且每台机器的版本库其实都是一样的，没有
主次之分。
注册一个GitHub帐号，就可以免费获得git远程仓库。由于你的本地Git
仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：
第一步，创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，
再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件。如果已经有了，
可以直接跳到下一步。
ssh-keygen -t rsa -C "youremail@example.com"
一路回车使用默认值就可以。
第二步，登录GitHub，打开"Account setting","SSH Keys",点"Add SSH
Key"，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容。
为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实
是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要
知道了你的公钥，就可以确认只有你自己才能推送。
当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司
提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以
在每台电脑上往GitHub推送了。
12.添加远程库
要关联一个远程库，使用命令
git remote add origin git@server-name:path/repo-name.git，如：
git remote add origin git@github.com:yemaozi2010/dbz.git
关联后，使用命令
git push -u origin master第一次推送master分支的所有内容。
此后，每次本地提交后，只要有必要，就可以使用命令
git push origin master推送最新修改。
分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的
存在，也就是有没有网络都可以正常工作，而SVN在没有联网的时候是拒绝
干活的！当有网络的时候，再把本地提交推送一下就完成了同步，非常
方便！
13.从远程库克隆
用命令git clone克隆一个本地库
 git clone git@github.com:yemaozi2010/gitskills.git
你也许还注意到，GitHub给出的地址不止一个，还可以用
https://github.com/michaelliao/gitskills.git这样的地址。
实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https
等其他协议。
使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入
口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能
用https。
Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。
14.分支管理
分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两
周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，
不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，
又存在丢失每天进度的巨大风险。
现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看
不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，
想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，
既安全，又不影响别人工作。
其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，
这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，
结果分支功能成了摆设，大家都不去用。
但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟
之内就能完成！无论你的版本库是1个文件还是1万个文件。
15.创建与合并分支
在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，
这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，
这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，
而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。
首先，我们创建dev分支，然后切换到dev分支。
git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：
git branch dev
git checkout dev
然后，用git branch命令查看当前分支，
然后，我们就可以在dev分支上正常提交，
dev分支的工作完成，我们就可以切换回master分支：
git checkout master
切换回master分支后，再查看一个gitnote.txt文件，刚才添加的内容不见了！
因为那个提交是在dev分支上，而master分支此刻的提交点并没有变。
现在，我们把dev分支的工作成果合并到master分支上：
git merge dev
git merge命令用于合并指定分支到当前分支。合并后，再查看gitnote.txt
的内容，就可以看到，和dev分支的最新提交是完全一样的。
注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，
也就是直接把master指向dev的当前提交，所以合并速度非常快。
当然，也不是每次合并都能Fast-forward，我们后面会将其他方式的合并。
合并完成后，就可以放心地删除dev分支了：
git branch -d dev
删除后，查看branch，就只剩下master分支了
git branch
因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，
合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。
Git鼓励大量使用分支：
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name>
16.解决冲突
git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
用git log --graph命令可以看到分支合并图
git log --graph --pretty=oneline --abbrev-commit
17.分支管理策略
通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，
删除分支后，会丢掉分支信息。
如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，
从分支历史上就可以看出分支信息。
准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：
git merge --no-ff -m "merge with no-ff" dev
合并后，我们用git log看看分支历史：
git log --graph --pretty=oneline --abbrev-commit
*   dbc6b77 Merge branch 'dev'
|\  
| * 77eabd9 dev content5
* |   88a6add just for dev content4
|\ \  
| |/  
| * a0178bc dev content4
|/  
* 96862c8 dev content3
* ccd6227 dev content2
* 04e7ebe dev content1
*   2862286 Merge branch 'dev'
|\  
| * 682b33e newly add
* |   1545211 Merge branch 'dev'
分支策略
在实际开发中，我们应该按照几个基本原则进行分支管理：
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在
上面干活；
那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，
比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地
往dev分支上合并就可以了。
合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，
能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。
18.Bug分支
当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支
issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：
并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。
但是，必须在两个小时内修复该bug，怎么办？
幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复
现场后继续工作：
git stash
现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），
因此可以放心地创建分支来修复bug。
首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master
创建临时分支：
git checkout master
git checkout -b issue-101
现在修复bug，需要把“Git is free software ...”改为“Git is a free
software ...”，然后提交：

just for stash test ....
test
